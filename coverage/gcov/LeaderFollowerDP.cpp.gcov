        -:    0:Source:LeaderFollowerDP.cpp
        -:    0:Graph:./LeaderFollowerDP.gcno
        -:    0:Data:./LeaderFollowerDP.gcda
        -:    0:Runs:5
        -:    1:#include "LeaderFollowerDP.hpp"
        -:    2:#define NO_LEADER -1
        -:    3:#define CONVERSATION 0
        -:    4:#define TASKS 1
        -:    5:/*
        -:    6:Working with 2 threads, one leader that handle the conversation with the client and preform the enqueue task.
        -:    7:And the other thread is the follower that will execute the task.
        -:    8:If the leader is done with the conversation, the follower will be promoted to leader.
        -:    9:If the leader is done execute all the tasks and queue is empty or cant preform the task, the follower will be promoted to leader.
        -:   10:*/
        -:   11:
        1:   12:LeaderFollowerDP::LeaderFollowerDP() : leaderIndex(NO_LEADER), stop(false), client_fd(-1) {
        -:   13:    try{
        1:   14:        this->threadsPool.push_back(std::thread(&LeaderFollowerDP::tasksEnqueing, this)); // Create the first thread for the leader to handle the conversation and enqueue tasks
        1:   15:        this->threadsPool.push_back(std::thread(&LeaderFollowerDP::tasksExecution, this)); // Create the second thread for the follower to execute the tasks
        1:   16:        std::cout<<"Created Threades"<<std::endl;
    =====:   17:    }catch(const std::exception& e){
    =====:   18:        std::cerr << "Error: " << e.what() << std::endl;
    =====:   19:    }
        1:   20:}
        -:   21:
    #####:   22:LeaderFollowerDP::~LeaderFollowerDP() {
    #####:   23:    std::cout<<"**** Closing Pattern Type ****"<<std::endl;
    #####:   24:    std::cout<<"Deleting Leader-Follower"<<std::endl;
        -:   25:    {
    #####:   26:        std::lock_guard<std::mutex> lock(mtx);
    #####:   27:        this->stop = true;
    #####:   28:        this->toCloseClient = true;
    #####:   29:    }
        -:   30:    
    #####:   31:    cv.notify_all(); // Notify all the threads to wake up and stop working by setting the stop flag to true
        -:   32:    
        -:   33:    // Join the threads (wait for the threads to finish)
    #####:   34:    for (auto& thread : threadsPool) {
    #####:   35:        if (thread.joinable()) {
    #####:   36:            thread.join();
        -:   37:        }
        -:   38:    }
    #####:   39:    tasksQueue.clear(); // Clear the queue of tasks
    #####:   40:    std::cout<<"Leader Follower Threads has Closed!"<<std::endl;
    #####:   41:}
        -:   42:
        -:   43:// Handle the client request
        1:   44:void LeaderFollowerDP::handleRequest(int& client_FD) {
        1:   45:    this->toCloseClient = false;
        1:   46:    std::cout<<"\n*** Leader-Follower - New Connection ***"<<std::endl;
        1:   47:    this->client_fd = client_FD;
        1:   48:    promoteFollower(CONVERSATION); // Promote the follower to leader to start the conversation with the client
        -:   49:    {
        1:   50:        std::unique_lock<std::mutex> lock(this->mtx); // Lock the mutex for the thread
       30:   51:        this->cv.wait(lock, [this] { return (this->toCloseClient || this->stop); }); // Wait for the client to close the connection or the stop flag to be set
        1:   52:    }
        1:   53:}
        -:   54:
        -:   55:// Start the conversation with the client
       62:   56:void LeaderFollowerDP::tasksEnqueing(){
        -:   57:    while(true){
       62:   58:        if(this->leaderIndex != CONVERSATION){ // Check if the leader index is not the conversation leader
       15:   59:            std::unique_lock<std::mutex> lock(this->mtx);
       15:   60:            std::cout<<"** Conversation Follower ** - Waiting For Promotion"<<std::endl;
       45:   61:            this->cv.wait(lock, [this] { return (this->leaderIndex == CONVERSATION || this->stop); }); // Wait for the leader index to be the conversation leader or the stop flag to be set
       14:   62:        }
        -:   63:
      61*:   64:        if (stop) break; // If the stop flag is set, break the loop and exit the thread
        -:   65:
      61*:   66:        if(this->client_fd < 0){ // Check if the client file descriptor is less than 0 (client has disconnected)
    #####:   67:            std::cout<<"\n** Client has Left **\n"<<std::endl;
    #####:   68:            this->toCloseClient = true;
    #####:   69:            promoteFollower(NO_LEADER); // Promote the follower to leader
    #####:   70:            continue; // Continue to the next iteration of the loop 
        -:   71:        }
        -:   72:        
        -:   73:        // Start the conversation with the client
        -:   74:        try{
       61:   75:            if(this->toCloseClient){ // Check if the client has disconnected
    #####:   76:                promoteFollower(NO_LEADER); // Promote the follower to leader
        -:   77:            }else{ // If the client is connected
       61:   78:                std::cout<<"Starting Conversation with Client: "<<client_fd<<std::endl;
       61:   79:                int choice = this->startConversation(this->client_fd);
        -:   80:                //If return false - client choice is 0 to execute tasks or 10 to exit
       61:   81:                if(!enqueingChoices(choice)) {  // If the choice is to execute tasks or exit
       14:   82:                    std::cout<<"\nPromoting Follower to Execute Tasks\n"<<std::endl;
       14:   83:                    promoteFollower(TASKS); // Promote the follower to leader to execute the tasks
        -:   84:                }
        -:   85:            }
    =====:   86:        }catch(const std::exception& e){
    =====:   87:            int follower = (client_fd < 0) ? NO_LEADER : CONVERSATION;
    =====:   88:            promoteFollower(follower);
    =====:   89:        }
       61:   90:    }
    #####:   91:}
        -:   92:
        -:   93:// Execute the tasks
       63:   94:void LeaderFollowerDP::tasksExecution(){
        -:   95:    while(true){
       63:   96:        if(this->leaderIndex != TASKS){
       15:   97:            std::unique_lock<std::mutex> lock(this->mtx);
       15:   98:            std::cout<<"** Task Follower ** - Waiting For Promotion"<<std::endl;
       45:   99:            this->cv.wait(lock, [this] { return this->leaderIndex == TASKS || this->stop; }); // Wait for the leader index to be the task leader or the stop flag to be set
       14:  100:        }
        -:  101:
      62*:  102:        if (stop) break; // If the stop flag is set, break the loop and exit the thread
        -:  103:
      62*:  104:        if(this->client_fd < 0){
    #####:  105:            std::cout<<"\n** Client has Left **\n"<<std::endl;
    #####:  106:            this->toCloseClient = true;
    #####:  107:            promoteFollower(NO_LEADER);
    #####:  108:            continue;
        -:  109:        }
        -:  110:
        -:  111:        try{
       62:  112:            if(this->toCloseClient){
        1:  113:                promoteFollower(NO_LEADER);
        -:  114:            }
       61:  115:            else if(this->tasksQueue.isEmpty()){
       13:  116:                std::cout<<"Tasks Queue is Empty"<<std::endl;
       13:  117:                promoteFollower(CONVERSATION);
        -:  118:            }else{
       48:  119:                bool success = this->tasksQueue.executeTask();
       48:  120:                if(!success){
        7:  121:                    sendMessage(this->client_fd, "Task execution failed. Try to use Healthy Logic. (Recommended)\n");
        7:  122:                    std::cout<<"*** Task Execution Failed - Dequeue and Keep Working ***"<<std::endl;
        -:  123:                }
        -:  124:            }
    =====:  125:        }catch(const std::exception& e){
    =====:  126:            int follower = (client_fd < 0) ? NO_LEADER : TASKS;
    =====:  127:            promoteFollower(follower);
    =====:  128:        }
       62:  129:    }
    #####:  130:}
        -:  131:
        -:  132:// Enqueue the choices
       61:  133:bool LeaderFollowerDP::enqueingChoices(int choice){
       61:  134:    TaskQueue::TaskType func;
       61:  135:    std::string message;
        -:  136:
       61:  137:    switch (choice) {
        2:  138:        case 1: // Create graph
        -:  139:            //define task to add to the equeue
        2:  140:            func = [this](int &client_fd, int choice) -> bool {
        4:  141:                return createGraph(client_fd);};
        2:  142:            break;
        -:  143:        
        9:  144:        case 2: // Add edge
        -:  145:        case 3: // Remove edge
        9:  146:            func = [this](int &client_fd, int choice) -> bool {
       18:  147:                return modifyGraph(client_fd, choice == 2);};
        9:  148:            break;
        -:  149:
        9:  150:        case 4: // Calculate MST
        9:  151:            func = [this](int &client_fd, int choice) -> bool {
       18:  152:                return calculateMST(client_fd);};
        9:  153:            break;
        -:  154:
       27:  155:        case 5: // MST operations
        -:  156:        case 6:
        -:  157:        case 7:
        -:  158:        case 8:
        -:  159:        case 9:
       27:  160:            func = [this](int &client_fd, int choice) -> bool {
       54:  161:                return getMSTData(client_fd, choice);};
       27:  162:            break;
        -:  163:        
        1:  164:        case 10: // Client Exit 
        2:  165:            func = [this](int &client_fd, int choice) -> bool {
        1:  166:                this->toCloseClient = true;
        2:  167:                return this->stopClient(client_fd);};
        -:  168:            
        1:  169:            this->tasksQueue.clear();  // Clear the queue of tasks client might entered
        1:  170:            this->tasksQueue.enqueue(func , this->client_fd, choice);
        1:  171:            return false;  // return value false execute the tasks
        -:  172:            
       13:  173:        case 0: // Start Executing the tasks 
       13:  174:            return false; // return value false to execute the tasks
    #####:  175:        default:  // Invalid choice - return to conversation
    #####:  176:            return true; // return value true to continue the conversation
        -:  177:    }
        -:  178:
       47:  179:    this->tasksQueue.enqueue(func , this->client_fd, choice);
       47:  180:    std::cout<<"Task Added"<<std::endl;
       47:  181:    return true;
       61:  182:}
        -:  183:
        -:  184:// Promote the follower to leader
       29:  185:void LeaderFollowerDP::promoteFollower(int follower){
        -:  186:    std::string leader = (follower == CONVERSATION) ?
       15:  187:                        "Promotion: Leader-Conversation" : (follower == TASKS) ?
       44:  188:                        "Promotion: Leader-Tasks" : "No-Leader";
       29:  189:    std::cout<<"\n****** "<<leader<<" ******"<<std::endl;
       29:  190:    this->leaderIndex = follower;
       29:  191:    this->cv.notify_all(); // Notify all the threads to wake up and start working 
       29:  192:}
