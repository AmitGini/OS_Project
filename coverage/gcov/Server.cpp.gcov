        -:    0:Source:Server.cpp
        -:    0:Graph:./Server.gcno
        -:    0:Data:./Server.gcda
        -:    0:Runs:5
        -:    1:#include "Server.hpp"
        -:    2:
        -:    3:// Constructor 
        2:    4:Server::Server(bool isPipe) {
        2:    5:    std::cout<<"Start Building the Server..."<<std::endl;
        -:    6:
        -:    7:    // Choose the Design pattern
        2:    8:    if(isPipe){
        1:    9:        std::cout<<"Starting Pipeline Design Pattern"<<std::endl;
        1:   10:        this->patternType = std::make_unique<PipeDP>();
        -:   11:    }else{
        1:   12:        std::cout<<"Starting Leader Follower Design Pattern"<<std::endl;
        1:   13:        this->patternType = std::make_unique<LeaderFollowerDP>();
        -:   14:    }
        -:   15:
        -:   16:
        -:   17:
        2:   18:    start();  // Start the server
        2:   19:}
        -:   20:
        -:   21:// Destructor
        2:   22:Server::~Server(){    
        2:   23:    std::cout << "\n********* Stopping Server *********" << std::endl;
        -:   24:
        2:   25:    clients_dataset.clear();
        2:   26:    patternType.reset();
        -:   27:
        2:   28:    std::cout<<"Closing Server File Descriptor..."<<std::endl;
        2:   29:    if (server_fd >= 0) {
        2:   30:        close(server_fd);
        -:   31:    }
        -:   32:
        2:   33:    std::cout<<"********* Server has Closed! *********"<<std::endl;
        2:   34:}
        -:   35:
        -:   36:// Start the server
        2:   37:void Server::start() {
        -:   38:    // Creating socket FD
        2:   39:    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
    #####:   40:        perror("socket failed");
    #####:   41:        exit(EXIT_FAILURE);
        -:   42:    }
        -:   43:
        -:   44:    // Set the socket options
        2:   45:    int opt = 1;
        2:   46:    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt))) {
    #####:   47:        perror("setsockopt");
    #####:   48:        exit(EXIT_FAILURE);
        -:   49:    }
        -:   50:
        -:   51:    // Set the address and port number
        2:   52:    address.sin_family = AF_INET;
        2:   53:    address.sin_addr.s_addr = INADDR_ANY;
        2:   54:    address.sin_port = htons(PORT);
        -:   55:
        -:   56:    // Bind the socket to the address and port number
        2:   57:    if (bind(server_fd, (struct sockaddr*)&address, sizeof(address)) < 0) {
    #####:   58:        perror("bind failed");
    #####:   59:        exit(EXIT_FAILURE);
        -:   60:    }
        -:   61:
        -:   62:    // Listen for incoming connections
        2:   63:    if (listen(server_fd, 3) < 0) {
    #####:   64:        perror("listen");
    #####:   65:        exit(EXIT_FAILURE);
        -:   66:    }
        -:   67:
        2:   68:    std::cout << "Server started listening on port " << PORT << std::endl;
        -:   69:
        -:   70:    // Handle incoming connections
        2:   71:    this->handleConnections();
        2:   72:}
        -:   73:
        2:   74:void Server::handleConnections() {
        2:   75:    int addrlen = sizeof(this->address);
        -:   76:    fd_set readfds;
        -:   77:    struct timeval timeout;
        2:   78:    int stdin_fd = fileno(stdin);
        2:   79:    int max_fd = std::max(server_fd, stdin_fd);
        -:   80:    
      155:   81:    while(!stopServer) {
     2635:   82:        FD_ZERO(&readfds);
      155:   83:        FD_SET(server_fd, &readfds);
      155:   84:        FD_SET(stdin_fd, &readfds);
        -:   85:
        -:   86:        // Set timeout to 1 second
      155:   87:        timeout.tv_sec = 1;
      155:   88:        timeout.tv_usec = 0;
        -:   89:
      155:   90:        int activity = select(max_fd + 1, &readfds, NULL, NULL, &timeout);
        -:   91:
     155*:   92:        if(activity < 0 && errno != EINTR) {
    #####:   93:            perror("select error");
    #####:   94:            continue;
        -:   95:        }
        -:   96:
        -:   97:        // Check for keyboard input
      155:   98:        if(FD_ISSET(stdin_fd, &readfds)) {
        2:   99:            std::string command;
        2:  100:            std::getline(std::cin, command);
        2:  101:            if(command == "stop") {
        2:  102:                std::cout << "Command: " << command << std::endl;
        2:  103:                stopServer = true;
        2:  104:                break;
        -:  105:            }
       2*:  106:        }
        -:  107:
        -:  108:        // Check for new connections
      153:  109:        if(FD_ISSET(server_fd, &readfds)) {
        2:  110:            int new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t*)&addrlen);
       2*:  111:            if (new_socket < 0) {
    #####:  112:                perror("accept failed");
    #####:  113:                continue;
        -:  114:            }
        -:  115:            
        2:  116:            std::lock_guard<std::mutex> lock(clients_mutex);
        2:  117:            std::cout << "New client connected!" << std::endl;
        -:  118:            auto client_thread = std::make_shared<std::thread>(
        2:  119:                &Server::acceptClientAccess, this, new_socket);
        2:  120:            clients_dataset.emplace_back(new_socket, std::move(client_thread));
        2:  121:            std::cout << "Client has Added to the Clients list!" << std::endl;
        2:  122:        }
        -:  123:    }
        2:  124:}
        2:  125:void Server::acceptClientAccess(int client_socket){
       2*:  126:    if(client_socket < 0) return;
        -:  127:    try {
        2:  128:        this->patternType->handleRequest(client_socket);
    =====:  129:    } catch (const std::exception& e) {
    =====:  130:        std::cerr << "Error handling client: " << e.what() << std::endl;
    =====:  131:    }
        -:  132:
        -:  133:    {
        2:  134:        std::lock_guard<std::mutex> lock(clients_mutex);
        2:  135:        auto it = std::find_if(clients_dataset.begin(), clients_dataset.end(),
        2:  136:            [client_socket](const auto& pair) { return pair.first == client_socket; });
        -:  137:            
        2:  138:        if (it != clients_dataset.end()) {
       2*:  139:            if(it->second && it->second->joinable()) {
        2:  140:                it->second->detach();
        -:  141:            }
        -:  142:            // Close socket before removing from vector
        2:  143:            if (close(client_socket) < 0) {
    #####:  144:                std::cerr << "Error closing socket: " << strerror(errno) << std::endl;
        -:  145:            }
        2:  146:            clients_dataset.erase(it);
        -:  147:        }
        2:  148:    }
        -:  149:
        -:  150:}
