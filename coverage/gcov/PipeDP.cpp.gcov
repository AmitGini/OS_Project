        -:    0:Source:PipeDP.cpp
        -:    0:Graph:./PipeDP.gcno
        -:    0:Data:./PipeDP.gcda
        -:    0:Runs:5
        -:    1:#include "PipeDP.hpp"
        -:    2:
        -:    3:#define STAGE_CREATE_GRAPH 0
        -:    4:#define STAGE_MODIFY_GRAPH 1
        -:    5:#define STAGE_CALCULATE_MST 2
        -:    6:#define STAGE_MST_OPERATIONS 3
        -:    7:#define STAGE_CLIENT_EXIT 4
        -:    8:#define STAGE_UNDEFINE -1 // Undefined stage for error handling
        -:    9:
        1:   10:PipeDP::PipeDP() : isStageActive(false) {
        1:   11:    setupPipe();
        1:   12:}
        -:   13:
    #####:   14:PipeDP::~PipeDP() {
    #####:   15:    std::cout<<"**** Closing Pattern Type ****"<<std::endl;
    #####:   16:    std::cout<<"Deleting PipeDP"<<std::endl;
    #####:   17:    this->isStageActive = false;
    #####:   18:    stages.clear();
    #####:   19:    std::cout<<"Pipe And Active Objects has Closed"<<std::endl;
    #####:   20:}
        -:   21:
        -:   22:// define the task handlers for each stage
        1:   23:void PipeDP::setupPipe() {
        -:   24:    try {
        -:   25:        // Pre-allocate vector capacity
        1:   26:        stages.reserve(STAGE_CLIENT_EXIT + 1); 
        -:   27:        
        -:   28:        // Create stages with error checking
        6:   29:        for(int i = STAGE_CREATE_GRAPH; i < STAGE_CLIENT_EXIT+ 1; ++i) {
        5:   30:            std::cout <<"***** "<< "Creating stage " << i <<" *****"<<std::endl;
        5:   31:            stages.push_back(std::make_shared<ActiveObjectDP>(i)); // Create a shared pointer to an active object
        5:   32:            std::cout << "Stage " << i << " created successfully" << std::endl;
        -:   33:        }
        -:   34:        
        1:   35:        std::cout<<"*******Here*******"<<std::endl;
        -:   36:
        -:   37:        // Set up the pipeline connections
        1:   38:        stages[STAGE_CREATE_GRAPH]->setNextStage(stages[STAGE_MODIFY_GRAPH]);
        1:   39:        stages[STAGE_MODIFY_GRAPH]->setNextStage(stages[STAGE_CALCULATE_MST]);
        1:   40:        stages[STAGE_CALCULATE_MST]->setNextStage(stages[STAGE_MST_OPERATIONS]);
        1:   41:        stages[STAGE_MST_OPERATIONS]->setNextStage(stages[STAGE_CLIENT_EXIT]);
        1:   42:        stages[STAGE_CLIENT_EXIT]->setNextStage(stages[STAGE_CLIENT_EXIT]);
        -:   43:
        1:   44:        stages[STAGE_CREATE_GRAPH]->setPrevStageStatus(true); // Set the first stage to active (because it's the first stage)
        -:   45:
        -:   46:        // Define task handlers for each stage
        1:   47:        stages[STAGE_CREATE_GRAPH]->setTaskHandler([this](int &client_FD, int choice) -> bool {
        2:   48:            std::cout<<"Set Task Handler for stage 0"<<std::endl;
        2:   49:            return createGraph(client_FD);
        -:   50:            
        -:   51:            
        -:   52:        });
        -:   53:
        1:   54:        stages[STAGE_MODIFY_GRAPH]->setTaskHandler([this](int &client_FD, int choice) -> bool {
        5:   55:            bool addOrRemoveEdge = (choice == 2); // 2 for add edge, 3 for remove edge
        5:   56:            std::cout<<"Set Task Handler for stage 1"<<std::endl;
        5:   57:            return modifyGraph(client_FD, addOrRemoveEdge);
        -:   58:
        -:   59:        });
        -:   60:
        1:   61:        stages[STAGE_CALCULATE_MST]->setTaskHandler([this](int &client_FD, int choice) -> bool {
        3:   62:            std::cout<<"Set Task Handler for stage 2"<<std::endl;
        3:   63:            return calculateMST(client_FD);
        -:   64:            
        -:   65:
        -:   66:        });
        -:   67:
        1:   68:        stages[STAGE_MST_OPERATIONS]->setTaskHandler([this](int &client_FD, int choice) -> bool {
        6:   69:            std::cout<<"Set Task Handler for stage 3"<<std::endl;
        6:   70:            getMSTData(client_FD, choice);
        6:   71:            return true; 
        -:   72:        });
        -:   73:
        1:   74:        stages[STAGE_CLIENT_EXIT]->setTaskHandler([this](int &client_FD, int choice) -> bool {
        1:   75:            std::cout<<"Set Task Handler for stage 4"<<std::endl;
        1:   76:            return stopClient(client_FD);
        -:   77:            
        -:   78:        });
        -:   79:        
    =====:   80:    } catch (const std::exception& e) {
    =====:   81:        std::cerr << "Stage creation failed: " << e.what() << std::endl;
    =====:   82:        stages.clear();
    =====:   83:        throw;
    =====:   84:    }
        1:   85:}
        -:   86:
        1:   87:void PipeDP::handleRequest(int& client_FD) {
       18:   88:    while (client_FD > 0) {
       18:   89:        int choice = startConversation(client_FD);
        -:   90:        
       34:   91:        int numStage = (choice == 1) ? STAGE_CREATE_GRAPH : 
       27:   92:            (choice == 2 || choice == 3) ? STAGE_MODIFY_GRAPH :
       19:   93:            (choice == 4) ? STAGE_CALCULATE_MST :
       10:   94:            (choice >= 5 && choice <= 9) ? STAGE_MST_OPERATIONS :
        2:   95:            (choice == 10) ? STAGE_CLIENT_EXIT : STAGE_UNDEFINE;
        -:   96:        
       18:   97:        std::cout<<"\n************* Stage "<<numStage<<" *************"<<std::endl;
        -:   98:
       18:   99:        switch (choice) {
        2:  100:            case 1: // Create graph
        2:  101:                this->stages[STAGE_CREATE_GRAPH]->enqueue(client_FD, choice);
        2:  102:                break;
        5:  103:            case 2: // Add edge
        -:  104:            case 3: // Remove edge
        5:  105:                this->stages[STAGE_MODIFY_GRAPH]->enqueue(client_FD, choice);
        5:  106:                break;
        3:  107:            case 4: // Compute MST
        3:  108:                this->stages[STAGE_CALCULATE_MST]->enqueue(client_FD, choice);
        3:  109:                break;
        6:  110:            case 5: // MST operations
        -:  111:            case 6:
        -:  112:            case 7:
        -:  113:            case 8:
        -:  114:            case 9:
        6:  115:                this->stages[STAGE_MST_OPERATIONS]->enqueue(client_FD, choice);
        6:  116:                break;
        1:  117:            case 10: // Exit
        1:  118:                this->stages[STAGE_CLIENT_EXIT]->enqueue(client_FD, choice);
        1:  119:                return;
        -:  120:        }
        -:  121:        
        -:  122:        // Wait for the stages to finish their work
      102:  123:        for(auto& stage : stages) {
       85:  124:            if(stage->isActive()) {
       14:  125:                stage->makePipeWait(this->pipeMtx, this);
       14:  126:                sleep(1);  // Sleep for 1 second in case next stages are still active, to avoid conition race
        -:  127:            }
        -:  128:        }
        -:  129:        
       17:  130:        std::cout<<"************************************"<<std::endl;
        -:  131:    }
        -:  132:}
        -:  133:
       28:  134:void PipeDP::setStageActiveStatus(bool status) {
       28:  135:     std::cout<<"Pipe Updated Working Status From: "<<this->isStageActive<<" To: "<<status<<std::endl; 
       28:  136:    this->isStageActive = status;
       28:  137:}
