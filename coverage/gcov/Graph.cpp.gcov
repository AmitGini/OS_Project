        -:    0:Source:Graph.cpp
        -:    1:#include "Graph.hpp"
        -:    2:
        -:    3:#define NO_MST_DATA_CALCULATION -1
        -:    4:#define PROGRESS_MST_DATA_CALCULATION 0
        -:    5:#define FINISH_MST_DATA_CALCULATION 1
        -:    6:#define INIT_INTEGER 0
        -:    7:#define INIT_DOUBLE 0.0
        -:    8:
        -:    9:
        -:   10:
    #####:   11:Graph::Graph(int vertices)
    #####:   12:    : numVertices(vertices), numEdges(INIT_INTEGER),
    #####:   13:      mstTotalWeight(INIT_INTEGER), mstLongestDistance(INIT_INTEGER), mstShortestDistance(INT_MAX),
    #####:   14:      mstAvgEdgeWeight(INIT_DOUBLE), mstDataStatus(NO_MST_DATA_CALCULATION),
    #####:   15:      mstStrategy(nullptr), mstMatrix(nullptr),
    #####:   16:      graphMatrix(vertices, std::vector<int>(vertices, INIT_INTEGER)) {}
        -:   17:
        -:   18:// Add edge to graph
    #####:   19:void Graph::addEdge(int u, int v, int weight)
        -:   20:{
    #####:   21:    if (u < 0 || u >= numVertices || v < 0 || v >= numVertices)
        -:   22:    {
    #####:   23:        throw std::out_of_range("Vertex index out of bounds");
        -:   24:    }
        -:   25:
    #####:   26:    else if (this->graphMatrix[u][v] != 0 || this->graphMatrix[v][u] != 0)
        -:   27:    {
    #####:   28:        this->graphMatrix[u][v] = weight;
    #####:   29:        this->graphMatrix[v][u] = weight; // Assuming undirected graph
    #####:   30:        return;
        -:   31:    }
        -:   32:    else
        -:   33:    {
    #####:   34:        this->graphMatrix[u][v] = weight;
    #####:   35:        this->graphMatrix[v][u] = weight; // Assuming undirected graph
    #####:   36:        this->numEdges++;
        -:   37:    }
        -:   38:}
        -:   39:
    #####:   40:void Graph::activateMSTStrategy()
        -:   41:{
    #####:   42:    if (this->mstStrategy != nullptr)
        -:   43:    {
        -:   44:        try 
        -:   45:        {
    #####:   46:            this->mstMatrix = std::move(this->mstStrategy->computeMST(this->graphMatrix));
        -:   47:        } 
    =====:   48:        catch (const std::exception& e) 
        -:   49:        {
    =====:   50:            std::cerr << "Error computing MST: " << e.what() << std::endl;
    =====:   51:        }
        -:   52:    }
        -:   53:    else
        -:   54:    {
    #####:   55:        std::cerr << "MST Strategy is not set" << std::endl;
        -:   56:    }
    #####:   57:}
        -:   58:
        -:   59:/*  Getters */
        -:   60:
        -:   61:// Get adjacency matrix represent the graph
    #####:   62:const std::vector<std::vector<int>> &Graph::getGraph() const
        -:   63:{
    #####:   64:    return this->graphMatrix;
        -:   65:}
        -:   66:
        -:   67:// Get number of vertices
    #####:   68:int Graph::getSizeVertices() const
        -:   69:{
    #####:   70:    return this->numVertices;
        -:   71:}
        -:   72:
    #####:   73:int Graph::getMSTTotalWeight() const
        -:   74:{
    #####:   75:    return this->mstTotalWeight;
        -:   76:}
        -:   77:
    #####:   78:int Graph::getMSTLongestDistance() const
        -:   79:{
    #####:   80:    return this->mstLongestDistance;
        -:   81:}
        -:   82:
    #####:   83:int Graph::getMSTShortestDistance() const
        -:   84:{
    #####:   85:    return this->mstShortestDistance;
        -:   86:}
        -:   87:
    #####:   88:int Graph::getMSTDataStatusCalculation() const
        -:   89:{
    #####:   90:    return this->mstDataStatus;
        -:   91:}
        -:   92:
    #####:   93:double Graph::getMSTAvgEdgeWeight() const
        -:   94:{
    #####:   95:    return this->mstAvgEdgeWeight;
        -:   96:}
        -:   97:
    #####:   98:bool Graph::getValidationMSTExist() const
        -:   99:{
    #####:  100:    return this->mstMatrix != nullptr;
        -:  101:}
        -:  102:
        -:  103:
        -:  104:
        -:  105:
        -:  106:/*  Setters */
        -:  107:
        -:  108:// Set the next status of the MST data calculation
    #####:  109:void Graph::setMSTDataCalculationNextStatus()
        -:  110:{
    #####:  111:    if (this->mstDataStatus == NO_MST_DATA_CALCULATION)
        -:  112:    {
    #####:  113:        this->mstDataStatus = PROGRESS_MST_DATA_CALCULATION;
        -:  114:    }
    #####:  115:    else if (this->mstDataStatus == PROGRESS_MST_DATA_CALCULATION)
        -:  116:    {
    #####:  117:        this->mstDataStatus = FINISH_MST_DATA_CALCULATION;
    #####:  118:    }else return;
        -:  119:}
        -:  120:
        -:  121:// Calculate and return the total weight of MST
    #####:  122:void Graph::setMSTTotalWeight()
        -:  123:{
    #####:  124:    if(mstMatrix == nullptr)
        -:  125:    {
    #####:  126:        return;
        -:  127:    }
    #####:  128:    int totalWeight = INIT_INTEGER;
    #####:  129:    for (int i = 0; i < this->numVertices; ++i)
        -:  130:    {
    #####:  131:        for (int j = i + 1; j < this->numVertices; ++j)
        -:  132:        {
    #####:  133:            totalWeight += (*this->mstMatrix)[i][j];
        -:  134:        }
        -:  135:    }
    #####:  136:    this->mstTotalWeight = totalWeight;
        -:  137:}
        -:  138:
        -:  139:// Return the highest weighted distance in the MST
    #####:  140:void Graph::setMSTLongestDistance()
        -:  141:{
    #####:  142:    if(mstMatrix == nullptr)
        -:  143:    {
    #####:  144:        return;
        -:  145:    }
    #####:  146:    int longestDistance = INIT_INTEGER;
    #####:  147:    int numVertices = this->numVertices;
        -:  148:
        -:  149:    // Use Floyd-Warshall algorithm to find the longest path in the MST
    #####:  150:    std::vector<std::vector<int>> dist = *this->mstMatrix;
        -:  151:
    #####:  152:    for (int k = 0; k < numVertices; ++k)
        -:  153:    {
    #####:  154:        for (int i = 0; i < numVertices; ++i)
        -:  155:        {
    #####:  156:            for (int j = 0; j < numVertices; ++j)
        -:  157:            {
    #####:  158:                if (dist[i][k] != 0 && dist[k][j] != 0)
        -:  159:                {
    #####:  160:                    int newDist = dist[i][k] + dist[k][j]; // new potential distance
        -:  161:                    // check if the current distaance from i to j is either zero or greater than the new potential distance
        -:  162:                    // if either condition is true it updates the distance from i to j to the new larger distance
    #####:  163:                    if (dist[i][j] == 0 || newDist < dist[i][j])
        -:  164:                    {
    #####:  165:                        dist[i][j] = newDist;
        -:  166:                    }
        -:  167:                }
        -:  168:            }
        -:  169:        }
        -:  170:    }
        -:  171:    // Find the longest distance in the shortest path matrix - after finish updating
    #####:  172:    for (int i = 0; i < numVertices; ++i)
        -:  173:    {
    #####:  174:        for (int j = i + 1; j < numVertices; ++j)
        -:  175:        {
    #####:  176:            if (dist[i][j] > longestDistance)
        -:  177:            {
    #####:  178:                longestDistance = dist[i][j];
        -:  179:            }
        -:  180:        }
        -:  181:    }
    #####:  182:    this->mstLongestDistance = longestDistance;
    #####:  183:}
        -:  184:
        -:  185:// Return the average edge weight in the MST
    #####:  186:void Graph::setMSTAvgEdgeWeight()
        -:  187:{
    #####:  188:    if(mstMatrix == nullptr)
        -:  189:    {
    #####:  190:        return;
        -:  191:    }
    #####:  192:    int numVertices = this->getSizeVertices();
    #####:  193:    double totalWeight = INIT_DOUBLE;
    #####:  194:    double edgeCount = INIT_DOUBLE;
        -:  195:
    #####:  196:    for (int i = 0; i < numVertices; ++i)
        -:  197:    {
    #####:  198:        for (int j = i + 1; j < numVertices; ++j)
        -:  199:        {
    #####:  200:            if ((*this->mstMatrix)[i][j] != 0)
        -:  201:            {
    #####:  202:                totalWeight += (*this->mstMatrix)[i][j];
    #####:  203:                ++edgeCount;
        -:  204:            }
        -:  205:        }
        -:  206:    }
        -:  207:
        -:  208:    // Prevent devision by zero
    #####:  209:    if (edgeCount == INIT_DOUBLE)
        -:  210:    {
    #####:  211:        this->mstAvgEdgeWeight = 0.0;
        -:  212:    }
    #####:  213:    this->mstAvgEdgeWeight = (totalWeight / edgeCount);
        -:  214:}
        -:  215:
        -:  216:
        -:  217:
    #####:  218:void Graph::setMSTShortestDistance()
        -:  219:{
    #####:  220:    if(mstMatrix == nullptr)
        -:  221:    {
    #####:  222:        return;
        -:  223:    }
    #####:  224:    int shortestDistance = INT_MAX;
    #####:  225:    int numVertices = this->numVertices;
        -:  226:
    #####:  227:    std::vector<std::vector<int>> dist = *this->mstMatrix; // Use Floyd-Warshall algorithm to find the shortest path in the MST
        -:  228:
    #####:  229:    for (int k = 0; k < numVertices; ++k)
        -:  230:    {
    #####:  231:        for (int i = 0; i < numVertices; ++i)
        -:  232:        {
    #####:  233:            for (int j = 0; j < numVertices; ++j)
        -:  234:            {
    #####:  235:                if (dist[i][k] != 0 && dist[k][j] != 0)
        -:  236:                {
    #####:  237:                    int newDist = dist[i][k] + dist[k][j]; // new potential distance
        -:  238:                    // Check if the current distance from i to j is either zero or greater than the new potential distance
        -:  239:                    // if either condition is true it updates the distance from i to j to the new smaller distance
    #####:  240:                    if (dist[i][j] == 0 || newDist < dist[i][j])
        -:  241:                    {
    #####:  242:                        dist[i][j] = newDist;
        -:  243:                    }
        -:  244:                }
        -:  245:            }
        -:  246:        }
        -:  247:    }
        -:  248:
        -:  249:    // Find the shortest distance in the shortest path matrix - after finish updating
    #####:  250:    for (int i = 0; i < numVertices; ++i)
        -:  251:    {
    #####:  252:        for (int j = i + 1; j < numVertices; ++j)
        -:  253:        {
    #####:  254:            if (dist[i][j] != 0 && dist[i][j] < shortestDistance)
        -:  255:            {
    #####:  256:                shortestDistance = dist[i][j];
        -:  257:            }
        -:  258:        }
        -:  259:    }
    #####:  260:    this->mstShortestDistance = (shortestDistance == INT_MAX) ? 0 : shortestDistance;
    #####:  261:}
        -:  262:
    #####:  263:void Graph::setMSTStrategy(std::unique_ptr<MSTStrategy> strategy)
        -:  264:{
    #####:  265:    this->mstStrategy = std::move(strategy);
    #####:  266:}
        -:  267:
        -:  268:// Get String to print of adjacency matrix represent the MST
    #####:  269:std::string Graph::printMST() const
        -:  270:{
    #####:  271:    if(mstMatrix == nullptr)
        -:  272:    {
    #####:  273:        return "No MST";
        -:  274:    }
    #####:  275:    std::stringstream mstString;
    #####:  276:    for (int i = 0; i < this->numVertices; ++i)
        -:  277:    {
    #####:  278:        for (int j = i + 1; j < this->numVertices; ++j)
        -:  279:        {
    #####:  280:            if ((*this->mstMatrix)[i][j] != 0)
        -:  281:            {
    #####:  282:                mstString << "Edge: " << i << " - " << j << " | Weight: " << (*mstMatrix)[i][j] << "\n";
        -:  283:            }
        -:  284:        }
        -:  285:    }
    #####:  286:    return mstString.str();
    #####:  287:}
