        -:    0:Source:Graph.cpp
        -:    0:Graph:./Graph.gcno
        -:    0:Data:./Graph.gcda
        -:    0:Runs:5
        -:    1:#include "Graph.hpp"
        -:    2:
        4:    3:Graph::Graph(int vertices): numVertices(vertices), numEdges(0), hasUpdatedMST(false),
        2:    4:        graphMatrix(vertices, std::vector<int>(vertices, 0)){}
        -:    5:
        -:    6:// Add edge to graph
        5:    7:void Graph::addEdge(int u, int v, int weight){
        5:    8:    validateVertices(u, v);
        5:    9:    if(this->graphMatrix[u][v] != 0 || this->graphMatrix[v][u] != 0){
        1:   10:        this->graphMatrix[u][v] = weight;
        1:   11:        this->graphMatrix[v][u] = weight; // Assuming undirected graph
        1:   12:        this->hasUpdatedMST = false;
        1:   13:        return;
        -:   14:    }else{
        4:   15:        this->graphMatrix[u][v] = weight;
        4:   16:        this->graphMatrix[v][u] = weight; // Assuming undirected graph
        4:   17:        this->numEdges++;
        4:   18:        this->hasUpdatedMST = false;
        -:   19:    }
        -:   20:}
        -:   21:
        -:   22:// Remove edge from graph
        3:   23:void Graph::removeEdge(int u, int v){
        3:   24:    validateVertices(u, v);
        3:   25:    if(this->graphMatrix[u][v] != 0 || this->graphMatrix[v][u] != 0){
        2:   26:        this->graphMatrix[u][v] = 0;
        2:   27:        this->graphMatrix[v][u] = 0;
        2:   28:        this->numEdges--;
        2:   29:        this->hasUpdatedMST = false;
        -:   30:    }
        3:   31:}
        -:   32:
        -:   33:// Get number of vertices
       31:   34:int Graph::getSizeVertices() const{
       31:   35:    return this->numVertices;
        -:   36:}
        -:   37:
        -:   38:// Get adjacency matrix represent the graph
       10:   39:const std::vector<std::vector<int>> &Graph::getGraph() const{
       10:   40:    return this->graphMatrix;
        -:   41:}
        -:   42:
       33:   43:bool Graph::hasMST() const{
       33:   44:    return this->hasUpdatedMST;
        -:   45:}
        -:   46:
        -:   47:// Set adjacency matrix represent the MST
       10:   48:void Graph::setMST(std::unique_ptr<std::vector<std::vector<int>>> mst) {
       10:   49:    if (!mst) {
    #####:   50:        return;
        -:   51:    }
       10:   52:    this->mstMatrix = std::move(mst);
       10:   53:    hasUpdatedMST = true;
        -:   54:}
        -:   55:
        -:   56:// Calculate and return the total weight of MST
        6:   57:int Graph::getMSTTotalWeight() const{
        6:   58:    int totalWeight = 0;
       36:   59:    for(int i = 0; i < this->numVertices; ++i){
       90:   60:        for(int j = i + 1; j < this->numVertices; ++j){
       60:   61:            totalWeight += (*this->mstMatrix)[i][j];
        -:   62:        }
        -:   63:    }
        6:   64:    return totalWeight;
        -:   65:}
        -:   66:
        -:   67:// Return the highest weighted distance in the MST
        6:   68:int Graph::getMSTLongestDistance() const {
        6:   69:    int longestDistance = 0;
        6:   70:    int numVertices = this->numVertices;
        -:   71:
        -:   72:    // Use Floyd-Warshall algorithm to find the longest path in the MST
        6:   73:    std::vector<std::vector<int>> dist = *this->mstMatrix;
        -:   74:
       36:   75:    for (int k = 0; k < numVertices; ++k) {
      180:   76:        for (int i = 0; i < numVertices; ++i) {
      900:   77:            for (int j = 0; j < numVertices; ++j) {
      750:   78:                if (dist[i][k] != 0 && dist[k][j] != 0) {
       20:   79:                    int newDist = dist[i][k] + dist[k][j]; // new potential distance
        -:   80:                    //check if the current distaance from i to j is either zero or greater than the new potential distance
        -:   81:                    //if either condition is true it updates the distance from i to j to the new larger distance
       20:   82:                    if (dist[i][j] == 0 || newDist < dist[i][j]) {
        8:   83:                        dist[i][j] = newDist;
        -:   84:                    }
        -:   85:                }
        -:   86:            }
        -:   87:        }
        -:   88:    }
        -:   89:    // Find the longest distance in the shortest path matrix - after finish updating
       36:   90:    for (int i = 0; i < numVertices; ++i) {
       90:   91:        for (int j = i + 1; j < numVertices; ++j) {
       60:   92:            if (dist[i][j] > longestDistance) {
        4:   93:                longestDistance = dist[i][j];
        -:   94:            }
        -:   95:        }
        -:   96:    }
        6:   97:    return longestDistance;
        6:   98:}
        -:   99:
        -:  100://Return the average edge weight in the MST
        7:  101:double Graph::getMSTAvgEdgeWeight() const{
        7:  102:    int numVertices = this->getSizeVertices();
        7:  103:    double totalWeight = 0.0;
        7:  104:    int edgeCount = 0;
        -:  105:
       42:  106:    for (int i = 0; i < numVertices; ++i) {
      105:  107:        for (int j = i + 1; j < numVertices; ++j) {
       70:  108:            if ((*this->mstMatrix)[i][j] != 0) {
        5:  109:                totalWeight += (*this->mstMatrix)[i][j];
        5:  110:                ++edgeCount;
        -:  111:            }
        -:  112:        }
        -:  113:    }
        7:  114:    if (edgeCount == 0) {
        2:  115:        return 0.0;
        -:  116:    }
        5:  117:    return totalWeight / edgeCount;
        -:  118:}
        -:  119:
        6:  120:int Graph::getMSTShortestDistance() const {
        6:  121:    int shortestDistance = INT_MAX;
        6:  122:    int numVertices = this->numVertices;
        -:  123:
        6:  124:    std::vector<std::vector<int>> dist = *this->mstMatrix;  // Use Floyd-Warshall algorithm to find the shortest path in the MST
        -:  125:
       36:  126:    for (int k = 0; k < numVertices; ++k) {
      180:  127:        for (int i = 0; i < numVertices; ++i) {
      900:  128:            for (int j = 0; j < numVertices; ++j) {
      750:  129:                if (dist[i][k] != 0 && dist[k][j] != 0) {
       20:  130:                    int newDist = dist[i][k] + dist[k][j]; // new potential distance
        -:  131:                    // Check if the current distance from i to j is either zero or greater than the new potential distance
        -:  132:                    // if either condition is true it updates the distance from i to j to the new smaller distance
       20:  133:                    if (dist[i][j] == 0 || newDist < dist[i][j]) {
        8:  134:                        dist[i][j] = newDist;
        -:  135:                    }
        -:  136:                }
        -:  137:            }
        -:  138:        }
        -:  139:    }
        -:  140:
        -:  141:    // Find the shortest distance in the shortest path matrix - after finish updating
       36:  142:    for (int i = 0; i < numVertices; ++i) {
       90:  143:        for (int j = i + 1; j < numVertices; ++j) {
       60:  144:            if (dist[i][j] != 0 && dist[i][j] < shortestDistance) {
        4:  145:                shortestDistance = dist[i][j];
        -:  146:            }
        -:  147:        }
        -:  148:    }
       12:  149:    return (shortestDistance == INT_MAX) ? 0 : shortestDistance;
        6:  150:}
        -:  151:
        7:  152:std::string Graph::printMST() const {
        7:  153:    std::stringstream mstString;
       42:  154:    for (int i = 0; i < this->numVertices; ++i) {
      105:  155:        for (int j = i + 1; j < this->numVertices; ++j) {
       70:  156:            if ((*this->mstMatrix)[i][j] != 0) {
        5:  157:                mstString << "Edge: " << i << " - " << j << " | Weight: " << (*mstMatrix)[i][j] << "\n";
        -:  158:            }
        -:  159:        }
        -:  160:    }
       14:  161:    return mstString.str();
        7:  162:}
        -:  163:
        8:  164:void Graph::validateVertices(int u, int v) const {
        8:  165:    if (u < 0 || u >= numVertices || v < 0 || v >= numVertices) {
    #####:  166:        throw std::out_of_range("Vertex index out of bounds");
        -:  167:    }
        8:  168:}
        -:  169:
